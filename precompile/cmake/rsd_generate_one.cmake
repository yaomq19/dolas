if(NOT DEFINED INPUT OR NOT DEFINED OUTPUT)
    message(FATAL_ERROR "rsd_generate_one.cmake requires -DINPUT=... -DOUTPUT=...")
endif()

# 有些生成器/命令行会把 -DINPUT="C:/a/b" 的引号保留在变量值里，导致 file(READ) 失败。
set(_in "${INPUT}")
set(_out "${OUTPUT}")
string(REGEX REPLACE "^\"(.*)\"$" "\\1" _in "${_in}")
string(REGEX REPLACE "^\"(.*)\"$" "\\1" _out "${_out}")

file(READ "${_in}" _rsd_text)

# RSD (XML) 格式：
# <rsd class_name="CameraRSD" file_suffix=".camera">
#   <field name="position" type="Vector3" />
# </rsd>

string(REGEX MATCH "class_name[ \t\r\n]*=[ \t\r\n]*\"([^\"]+)\"" _m_class "${_rsd_text}")
set(_class_name "${CMAKE_MATCH_1}")

string(REGEX MATCH "file_suffix[ \t\r\n]*=[ \t\r\n]*\"([^\"]+)\"" _m_suffix "${_rsd_text}")
set(_file_suffix "${CMAKE_MATCH_1}")

if(_class_name STREQUAL "")
    message(FATAL_ERROR "RSD missing required attribute: class_name (${_in})")
endif()
if(_file_suffix STREQUAL "")
    message(FATAL_ERROR "RSD missing required attribute: file_suffix (${_in})")
endif()

# CMake 的 list 用 ';' 分隔，但 XML 实体也含 ';'（&lt; / &gt; / &amp;）。
# 我们先把 ';' 替换掉，再做 MATCHALL，避免一个 <field ...> 被拆成多个 list 元素。
set(_rsd_text_safe "${_rsd_text}")
string(REPLACE ";" "__SC__" _rsd_text_safe "${_rsd_text_safe}")
string(REGEX MATCHALL "<field[^>]*>" _field_tags "${_rsd_text_safe}")

set(_field_lines "")
set(_field_desc_lines "")
set(_need_map FALSE)
set(_need_set FALSE)
set(_need_vector FALSE)
set(_need_string FALSE)
set(_need_nlohmann_json FALSE)

function(_trim _in _out)
    set(_s "${_in}")
    string(REGEX REPLACE "^[ \t\r\n]+" "" _s "${_s}")
    string(REGEX REPLACE "[ \t\r\n]+$" "" _s "${_s}")
    set(${_out} "${_s}" PARENT_SCOPE)
endfunction()

function(_split_toplevel_commas _in _out_list)
    # 按顶层逗号拆分（忽略 < > 内的逗号）
    set(s "${_in}")
    set(depth 0)
    set(cur "")
    set(out "")
    string(LENGTH "${s}" n)
    if(n EQUAL 0)
        set(${_out_list} "" PARENT_SCOPE)
        return()
    endif()
    math(EXPR last "${n}-1")
    foreach(i RANGE 0 ${last})
        string(SUBSTRING "${s}" ${i} 1 c)
        if(c STREQUAL "<")
            math(EXPR depth "${depth}+1")
        elseif(c STREQUAL ">")
            math(EXPR depth "${depth}-1")
        endif()

        if(c STREQUAL "," AND depth EQUAL 0)
            _trim("${cur}" cur_t)
            list(APPEND out "${cur_t}")
            set(cur "")
        else()
            set(cur "${cur}${c}")
        endif()
    endforeach()

    _trim("${cur}" cur_t)
    if(NOT cur_t STREQUAL "")
        list(APPEND out "${cur_t}")
    endif()
    set(${_out_list} "${out}" PARENT_SCOPE)
endfunction()

function(_cpp_type _spec _out_type _out_suffix)
    _trim("${_spec}" spec)

    if(spec STREQUAL "Float")
        set(t "Float")
        set(sfx "")
    elseif(spec STREQUAL "Double")
        set(t "Double")
        set(sfx "")
    elseif(spec STREQUAL "Int")
        set(t "Int")
        set(sfx "")
    elseif(spec STREQUAL "UInt")
        set(t "UInt")
        set(sfx "")
    elseif(spec STREQUAL "Bool")
        set(t "Bool")
        set(sfx "")
    elseif(spec STREQUAL "String")
        set(t "std::string")
        set(sfx "")
        set(_need_string TRUE PARENT_SCOPE)
    elseif(spec STREQUAL "Vector3")
        set(t "Vector3")
        set(sfx "")
    elseif(spec STREQUAL "Vector4")
        set(t "Vector4")
        set(sfx "")
    elseif(spec STREQUAL "Json")
        set(t "nlohmann::json")
        set(sfx "")
        set(_need_nlohmann_json TRUE PARENT_SCOPE)
    elseif(spec STREQUAL "Xml")
        set(t "std::string")
        set(sfx "")
        set(_need_string TRUE PARENT_SCOPE)
    elseif(spec STREQUAL "TriangleList")
        # TODO: 后续可升级为 enum/强类型；目前先保证可编译
        set(t "std::string")
        set(sfx "")
        set(_need_string TRUE PARENT_SCOPE)
    else()
        string(FIND "${spec}" "<" lt)
        string(FIND "${spec}" ">" gt REVERSE)
        if(lt GREATER -1 AND gt GREATER -1 AND gt GREATER lt)
            string(SUBSTRING "${spec}" 0 ${lt} base)
            math(EXPR inside_len "${gt}-${lt}-1")
            math(EXPR inside_off "${lt}+1")
            string(SUBSTRING "${spec}" ${inside_off} ${inside_len} inside)
            _trim("${base}" base)
            _trim("${inside}" inside)

            if(base STREQUAL "DynamicArray")
                _cpp_type("${inside}" inner_t inner_sfx)
                set(t "std::vector<${inner_t}>")
                set(sfx "")
                set(_need_vector TRUE PARENT_SCOPE)
            elseif(base STREQUAL "Set")
                _cpp_type("${inside}" inner_t inner_sfx)
                set(t "std::set<${inner_t}>")
                set(sfx "")
                set(_need_set TRUE PARENT_SCOPE)
            elseif(base STREQUAL "Map")
                _split_toplevel_commas("${inside}" args)
                list(LENGTH args argc)
                if(NOT argc EQUAL 2)
                    message(FATAL_ERROR "Map<K,V> expects 2 args: ${spec}")
                endif()
                list(GET args 0 kspec)
                list(GET args 1 vspec)
                _cpp_type("${kspec}" kt ksfx)
                _cpp_type("${vspec}" vt vsfx)
                set(t "std::map<${kt}, ${vt}>")
                set(sfx "")
                set(_need_map TRUE PARENT_SCOPE)
            elseif(base STREQUAL "StaticArray")
                _split_toplevel_commas("${inside}" args)
                list(LENGTH args argc)
                if(NOT argc EQUAL 2)
                    message(FATAL_ERROR "StaticArray<T,N> expects 2 args: ${spec}")
                endif()
                list(GET args 0 espec)
                list(GET args 1 nstr)
                _trim("${nstr}" nstr_t)
                if(NOT nstr_t MATCHES "^[0-9]+$")
                    message(FATAL_ERROR "StaticArray size must be integer: ${spec}")
                endif()
                _cpp_type("${espec}" et esfx)
                set(t "${et}")
                set(sfx "[${nstr_t}]")
            elseif(base STREQUAL "AssetReference")
                # TODO: 后续可生成 AssetReference<T>；目前先降级成路径字符串
                set(t "std::string")
                set(sfx "")
                set(_need_string TRUE PARENT_SCOPE)
            else()
                set(t "${spec}")
                set(sfx "")
            endif()
        else()
            set(t "${spec}")
            set(sfx "")
        endif()
    endif()

    set(${_out_type} "${t}" PARENT_SCOPE)
    set(${_out_suffix} "${sfx}" PARENT_SCOPE)
endfunction()

function(_field_type_enum type_spec out_enum)
    set(t "${type_spec}")
    if(t STREQUAL "String")
        set(e "RsdFieldType::String")
    elseif(t STREQUAL "Bool")
        set(e "RsdFieldType::BoolValue")
    elseif(t STREQUAL "Int")
        set(e "RsdFieldType::IntValue")
    elseif(t STREQUAL "UInt")
        set(e "RsdFieldType::UIntValue")
    elseif(t STREQUAL "Float")
        set(e "RsdFieldType::FloatValue")
    elseif(t STREQUAL "Vector3")
        set(e "RsdFieldType::Vector3")
    elseif(t STREQUAL "Vector4")
        set(e "RsdFieldType::Vector4")
    elseif(t STREQUAL "DynamicArray<Xml>")
        set(e "RsdFieldType::DynArrayXml")
    elseif(t STREQUAL "DynamicArray<Float>")
        set(e "RsdFieldType::DynArrayFloat")
    elseif(t STREQUAL "DynamicArray<UInt>")
        set(e "RsdFieldType::DynArrayUInt")
    elseif(t STREQUAL "Map<String, Vector4>")
        set(e "RsdFieldType::MapStringVector4")
    elseif(t STREQUAL "Map<String, String>")
        set(e "RsdFieldType::MapStringString")
    elseif(t STREQUAL "Map<String, Float>")
        set(e "RsdFieldType::MapStringFloat")
    else()
        set(e "RsdFieldType::Unsupported")
    endif()
    set(${out_enum} "${e}" PARENT_SCOPE)
endfunction()

foreach(tag IN LISTS _field_tags)
    string(REPLACE "__SC__" ";" tag "${tag}")

    string(REGEX MATCH "name[ \t\r\n]*=[ \t\r\n]*\"([^\"]+)\"" _mn "${tag}")
    set(k "${CMAKE_MATCH_1}")
    string(REGEX MATCH "type[ \t\r\n]*=[ \t\r\n]*\"([^\"]+)\"" _mt "${tag}")
    set(v "${CMAKE_MATCH_1}")

    if(k STREQUAL "" OR v STREQUAL "")
        message(FATAL_ERROR "Invalid <field> tag (missing name/type): ${tag} in ${_in}")
    endif()

    # XML 实体解码（我们用正则解析，不走 XML parser）
    string(REPLACE "&lt;" "<" v "${v}")
    string(REPLACE "&gt;" ">" v "${v}")
    string(REPLACE "&amp;" "&" v "${v}")

    _cpp_type("${v}" cpp_t cpp_sfx)
    set(_field_lines "${_field_lines}    ${cpp_t} ${k}${cpp_sfx};\n")

    _field_type_enum("${v}" field_enum)
    set(_field_desc_lines "${_field_desc_lines}        {\"${k}\", ${field_enum}, offsetof(${_class_name}, ${k})},\n")
endforeach()

list(LENGTH _field_tags _field_count)

get_filename_component(_rsd_name "${_in}" NAME)
set(_header "")
string(APPEND _header "// Auto-generated by precompile (RSD -> .h). DO NOT EDIT.\n")
string(APPEND _header "// Source: ${_rsd_name}\n\n")
string(APPEND _header "#pragma once\n\n")
string(APPEND _header "#include <string>\n")
string(APPEND _header "#include <vector>\n")
string(APPEND _header "#include <map>\n")
string(APPEND _header "#include <set>\n")
string(APPEND _header "#include <array>\n")
string(APPEND _header "#include <cstddef>\n\n")

if(_need_nlohmann_json)
    string(APPEND _header "#include <nlohmann/json.hpp>\n")
endif()

string(APPEND _header "#include \"base/dolas_base.h\"\n")
string(APPEND _header "#include \"core/dolas_math.h\"\n")
string(APPEND _header "#include \"common/rsd_field.h\"\n\n")

string(APPEND _header "namespace Dolas {\n\n")
string(APPEND _header "struct ${_class_name}\n{\n")
string(APPEND _header "    static constexpr const char* kFileSuffix = \"${_file_suffix}\";\n")
string(APPEND _header "${_field_lines}")
string(APPEND _header "\n    static const std::array<RsdFieldDesc, ${_field_count}> kFields;\n")
string(APPEND _header "};\n\n")
string(APPEND _header "inline const std::array<RsdFieldDesc, ${_field_count}> ${_class_name}::kFields = {{\n${_field_desc_lines}}};\n\n")
string(APPEND _header "} // namespace Dolas\n")

# 仅当内容变化时才写文件，避免无意义的全量重编译
set(_old "")
if(EXISTS "${_out}")
    file(READ "${_out}" _old)
endif()
if(NOT _old STREQUAL _header)
    get_filename_component(_out_dir "${_out}" DIRECTORY)
    file(MAKE_DIRECTORY "${_out_dir}")
    file(WRITE "${_out}" "${_header}")
endif()


